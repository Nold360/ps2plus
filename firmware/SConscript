from pprint import pprint
from source_utilities import *

# Import the build build_environment, platform, and target information
Import('build_env')
Import('platform')
Import('target')

# Add preprocessor defines
build_env.Append(CPPDEFINES=[
    # This define switches between firmware targets (i.e.: firmware and bootloader)
    'PS2PLUS_' + target.upper(),
    
    # This define specifies which microcontroller is being built -- it selects which
    # platform abstraction support to build
    'PLATFORM_' + platform.name,

    # This define puts the microcontroller name as a version number in the binary
    'PLATFORM_MICROCONTROLLER=' + platform.name,
])

# Add include directories
build_env.Append(CPPPATH=[
    '#/firmware/src',
    '#/'
])

# Collect the source files we care about
main_sources = GlobRecursive(build_env, 'src/**/*.c')
main_headers = GlobRecursive(build_env, 'src/**/*.h')
shared_sources = GlobRecursive(build_env, '../shared/**/*.c')
shared_headers = GlobRecursive(build_env, '../shared/**/*.h')

# Compile sources to objects
main_objects = build_env.Object(main_sources)
shared_objects = [ExternalObject(build_env, '../', path) for path in shared_sources]
objects = main_objects + shared_objects

# Output the VSCode C/C++ configuration for this platform/target
vscode_configuration = build_env.VSCodeCCppPropertiesConfiguration( 
    name=f'{platform.name}:{target}',
    properties=platform.toolchain.vscode_properties)

# Add this platform/target to the platform's IDE project generation step (if any)
platform.generate_ide_project_configuration_for_target(build_env, target)

# Compile the target
output = build_env.Program(target, objects)

# Send back source and header files
sources = main_sources + main_headers + shared_sources + shared_headers
Return('output', 'sources', 'vscode_configuration')